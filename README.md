
# KoCo | í•œêµ­ ì½”ìŠ¤ë©”í‹± ì•±

![KoCo_En_1](https://github.com/user-attachments/assets/0a1f5473-9fd5-498f-9dc6-7cce7d4ebf9f) |![KoCo_En_2](https://github.com/user-attachments/assets/4ea1a0bd-d490-4dbb-8025-e5d9ea6e85f5) |![KoCo_En_3](https://github.com/user-attachments/assets/f04a665d-f289-4bb1-936a-2ca2926f355f) |![KoCo_En_4](https://github.com/user-attachments/assets/e5b688ae-4fb8-43fa-baaf-2258e7add4f8)
--- | --- | --- | --- |



<br/><br/>

## ğŸª— KoCo (Korea Cosmetic) 
- ì•± ì†Œê°œ : Kë·°í‹°ì— ê´€ì‹¬ìˆëŠ” ì™¸êµ­ì¸ ê´€ê´‘ê°ë“¤ì„ ìœ„í•œ ì½”ìŠ¤ë©”í‹± ë§¤ì¥/ìƒí’ˆ ê¸°ë¡ ì•±
- ê°œë°œ ì¸ì› : 1ì¸
- ê°œë°œ ê¸°ê°„ : ì•½ 3ì£¼
- ìµœì†Œ ë²„ì „ : 16.0


<br/><br/>

## ğŸ“ ê¸°ìˆ  ìŠ¤íƒ
- UI : SwiftUI
- Reactive : Combine
- Network : URLSession
- Architecture : MVVM
- Local DB : Realm
- ETC. : KakaoMapSDK, CoreLocation, GitHub Actions


<br/><br/>



## ğŸ“ í•µì‹¬ ê¸°ëŠ¥
- ìœ„ì¹˜ ê¸°ë°˜ ì£¼ë³€ ì½”ìŠ¤ë©”í‹± ë§¤ì¥ ê²€ìƒ‰
- ê¸°ê¸°ì— ì €ì¥ëœ ì–¸ì–´ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì–¸ì–´ í˜„ì§€í™”(í•œêµ­ì–´, ì˜ì–´, ì¤‘êµ­ì–´)
- íŠ¹ì • ë§¤ì¥ì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ì œê³µ
- ë§¤ì¥ì— ëŒ€í•œ ë¦¬ë·° ì‘ì„± ë° í”Œë˜ê·¸ ê¸°ëŠ¥


<br/><br/>


## âœ… í•µì‹¬ ê¸°ìˆ  êµ¬í˜„ ì‚¬í•­
- Github Submoduleê³¼ Lokaliseë¥¼ ê²°í•©í•´ ì‚¬ìš©í•˜ì—¬ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ Project Repositoryì™€ ë¶„ë¦¬í•˜ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬
- Github Actionsë¥¼ í™œìš©í•˜ì—¬ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ì—…ë°ì´íŠ¸ë¡œ ì¸í•œ Submodule Repositoryì˜ PR ìƒì„± ì‹œì ë¶€í„° Project Repositoryì— Submoduleì„ ìµœì‹ í™” í•˜ëŠ” ê³¼ì •ê¹Œì§€ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ê´€ë¦¬
- ETag(Entity tag) ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹± ë„ì…ìœ¼ë¡œ ì„œë²„ì™€ ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ ë²„ì „ ë™ê¸°í™” ë° ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„/ì„œë²„ ë¶€í•˜ ê°ì¶•
- ë°ì´í„° ì†ŒìŠ¤ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ì¤„ì´ê¸° ìœ„í•´ Repository Patternì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ì ‘ê·¼ ë¡œì§ì„ ì¶”ìƒí™”
- UIì— ê´€í•œ inputì„ viewModelì— ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬í•˜ê¸° ìœ„í•´ viewModel ë‚´ ì—´ê±°í˜•ìœ¼ë¡œ Action ì •ì˜
- ì´ë²¤íŠ¸ì— ë”°ë¼ ViewModelì˜ actionë©”ì„œë“œì— Actionì—´ê±°í˜•ì„ ì¸ìë¡œ ì „ë‹¬í•˜ì—¬ ë‹¨ë±¡í–¥ ë°ì´í„° ë°”ì¸ë”© ì§€í–¥ì ì¸ êµ¬ì¡° ì„¤ê³„
- ë§¤ì¥ ë¦¬ë·°ì— ì—…ë¡œë“œí•œ ì‚¬ì§„ì„ ì˜êµ¬ì ìœ¼ë¡œ ì €ì¥í•˜ê³  ì¡°íšŒí•˜ê¸° ìœ„í•´ FileManager ì‚¬ìš©í•˜ì—¬ ì €ì¥/ì¡°íšŒ ë¡œì§ êµ¬í˜„
- UIKit ê¸°ë°˜ ì½”ë“œë¥¼ SwiftUI í”„ë¡œì íŠ¸ì— ì‚¬ìš©í•˜ê¸° ìœ„í•´ UIViewRepresentable, Coordinatorì„ ê¸°ë°˜ìœ¼ë¡œ ë˜í•‘
- CoreLocationì„ ì‚¬ìš©í•´ ìœ„ì¹˜ ê¶Œí•œ ë° ì‚¬ìš©ìì˜ ìœ„ì¹˜ ì •ë³´ íšë“


<img width="800" alt="Architecture(KoCo)" src="https://github.com/user-attachments/assets/33b06824-205d-4752-8dc0-ea7275171e3e" />


<br/><br/>


## ğŸ’ ì£¼ìš” êµ¬í˜„ ë‚´ìš©
### 1. ETagÂ ê¸°ë°˜Â ImageÂ CacheÂ ì „ëµÂ ìˆ˜ë¦½ ë° ì´ë¯¸ì§€ ë¡œë”© ì„±ëŠ¥ 4ë°° í–¥ìƒ

#### ETag(Entity tag)ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹œ ë„ì… ì´ìœ 
1. ë„¤íŠ¸ì›Œí¬ ë¶€í•˜ ê°ì†Œ : remoteDBì— ì €ì¥ëœ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë„¤íŠ¸ì›Œí‚¹ì— ëŒ€í•œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì„ ìµœì†Œí™”
2. ë¡œë“œ ì‹œê°„ ë‹¨ì¶• : ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„ì„ ë‹¨ì¶•ìœ¼ë¡œ ì‚¬ìš©ì ê²½í—˜ ê°œì„ 
3. ë¦¬ì†ŒìŠ¤ ë³€ê²½ ì—¬ë¶€ ì„œë²„ì™€ ë™ê¸°í™” : ETag ê¸°ë°˜ì˜ ì´ë¯¸ì§€ ìºì‹± ìœ¼ë¡œ ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ ë³€ê²½ì— ëŒ€í•´ ì„œë²„ì™€ ë™ê¸°í™”

#### ì´ë¯¸ì§€ ìºì‹± í”Œë¡œìš°
- ë©”ëª¨ë¦¬ ìºì‹œ Hit -> ë””ìŠ¤í¬ ìºì‹œ Hit
- -> ë©”ëª¨ë¦¬ í˜¹ì€ ë””ìŠ¤í¬ì— ì €ì¥í•´ ë†“ì€ ë°ì´í„°(etag, ì´ë¯¸ì§€ url ë“±)ê°€ ìˆë‹¤ë©´ í—¤ë”ì— 'If-None-Match'ë¥¼ ë„£ì–´ì„œ ì„œë²„ì— ìš”ì²­
- -> 304(Not Modified)ì—ëŸ¬ì˜ ê²½ìš° ê¸°ì¡´ì— ìºì‹±í•´ ë‘” ë°ì´í„° ë¦¬í„´ / ìƒíƒœì½”ë“œê°€ 200ì¼ ê²½ìš°ì—ëŠ” ìƒˆë¡œ ë°›ì€ ë°ì´í„° ë¦¬í„´

<img width="1127" alt="imageCache(etag)" src="https://github.com/user-attachments/assets/45f59867-69e2-4b00-845a-2b799591f64b" />


#### ì´ë¯¸ì§€ ìºì‹œ ë§¤ë‹ˆì €
- CombineÂ Operatorë¥¼Â í™œìš©í•œÂ StreamÂ ê´€ë¦¬
- ImageCachPolicy Enumì„ í†µí•´ ìºì‹± ì •ì±… ê´€ë¦¬

```swift 

final class ImageCacheManager {
    // ...
    
    enum ImageCachPolicy {
        case both
        case memoryOnly
        case diskOnly
    }
    
    // ...

    func getImageData(urlString : String, policy : ImageCachPolicy = .both) -> AnyPublisher<Data?, ImageLoadError> {
        let subject = PassthroughSubject<CacheImage?, ImageLoadError>()
        
        switch policy {
        case .both:
            hitMemoryCache(urlString: urlString)
                .catch { [weak self] imageLoadError  in //ë©”ëª¨ë¦¬ì— ìºì‹±ë˜ì–´ ìˆì§€ ì•Šì„ ë•Œ
                    guard let self else{
                        return Just<CacheImage?>(nil)
                            .setFailureType(to: ImageLoadError.self)
                            .eraseToAnyPublisher()
                    }
                    //ë””ìŠ¤í¬ ìºì‹œ ì¡°íšŒ
                    return self.hitDiskCache(urlString: urlString)
                }
                .subscribe(subject)
                .store(in: &cancellables)
            
        case .memoryOnly:
            // ...
 
        case .diskOnly:
            // ...
        }

        return subject
            .catch { imageLoadError  in
                
                //ë©”ëª¨ë¦¬&ë””ìŠ¤í¬ì— ìºì‹±ë˜ì§€ ì•Šì•˜ë‹¤ëŠ” ì—ëŸ¬ë¥¼ ë°›ì€ ê²½ìš° -> ê¸°ë³¸ê°’ìœ¼ë¡œ ë‚´ë ¤ë³´ëƒ„
                return Just(CacheImage(imageData: Data(), etag: "-"))
                
            }
            .flatMap{[weak self] resultImage -> AnyPublisher<(Data,String?), ImageLoadError> in
                guard let self, let resultImage else {
                    return Fail(error: ImageLoadError.undefinedError).eraseToAnyPublisher()
                }
                let cachedEtag = resultImage.etag
                let cachedImageData = resultImage.imageData
                return self.synchronizeWithServer(urlString : urlString, etag: cachedEtag, cachedImageData : cachedImageData, policy: policy)
                    
            }
            .tryMap {[weak self] (imageData, etag) in
                guard let self else {return imageData}
                return imageData
            }
            .mapError{$0 as! ImageLoadError}
            .eraseToAnyPublisher()

    }
    
    // ...

}

```

#### ì„œë²„ ë°ì´í„° ì¼ì¹˜ ì—¬ë¶€ í™•ì¸ ë° 304(Not Modified)ì—ëŸ¬ ë¶„ê¸°ì²˜ë¦¬
- If-None-Match í—¤ë”ë¥¼ ì¶”ê°€í•œ http ìš”ì²­ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ì¼ì¹˜ ì—¬ë¶€ í™•ì¸
- ì‘ë‹µì˜ statusCodeë¥¼ í†µí•´ 304ì—ëŸ¬ ë¶„ê¸° ì²˜ë¦¬


```swift 

    func synchronizeWithServer(urlString: String, etag : String, cachedImageData : Data, policy : ImageCachPolicy) -> AnyPublisher<(Data, String?), ImageLoadError> {

        guard let url = URL(string: urlString) else {
            return Fail<(Data, String?), ImageLoadError>(error: ImageLoadError.invalidUrlString).eraseToAnyPublisher()
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.addValue(etag, forHTTPHeaderField: "If-None-Match")

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { [weak self] result -> (Data, String?) in
                guard let self, let httpResponse = result.response as? HTTPURLResponse else {
                    throw ImageLoadError.noResponse
                }
                
                switch httpResponse.statusCode {
                case 200: // ì €ì¥ëœ etagë‘ ê°’ì´ ë‹¤ë¦„ -> ì‘ë‹µìœ¼ë¡œ ë°›ì€ ë°ì´í„° ë¦¬í„´
                    guard let newETag = httpResponse.allHeaderFields["Etag"] as? String else {
                        return (result.data, nil)
                    }
                    
                    //etag ê°€ ìˆì„ ê²½ìš° ìºì‹± ì •ì±…ëŒ€ë¡œ ìºì‹±
                    self.cacheImage(urlString: urlString, imageData: result.data, etag: newETag, policy: policy)
                    return (result.data, newETag)
                    
                case 304: // ì €ì¥ëœ etagë‘ ê°™ìŒ -> ì €ì¥ë˜ì–´ìˆë˜ ì´ë¯¸ì§€ ë°˜í™˜
                    return (cachedImageData, etag)
                default:
                    throw ImageLoadError.undefinedStatusCode
                }

            }
            .mapError { error -> ImageLoadError in
                if let error = error as? ImageLoadError {
                    return error
                } else {
                    return ImageLoadError.unknownError
                }
            }
            .eraseToAnyPublisher()

    }

```

#### OSLogì™€ instrumentë¥¼ ì‚¬ìš©í•œ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ ë¶„ì„
- OSLogì˜ os_signpost ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìºì‹± ì „í›„ì˜ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ ê¸°ë¡
- instrumentì˜ System Traceë¥¼ í™œìš©í•´ ë¡œë“œ ì†ë„ ë¶„ì„

ğŸ“ ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„ 75% ë‹¨ì¶•

> Before : ìºì‹± ì ìš© ì „ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ 
<img width="450" alt="before_imageCache" src="https://github.com/user-attachments/assets/0d91ff16-3e88-46c9-b904-a65c43673a33" />

> After : ìºì‹± ì ìš© í›„ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„
<img width="450" alt="after_imageCache" src="https://github.com/user-attachments/assets/1975089d-ea8b-4f7a-b020-705111152646" />


<br/><br/>

### 2. Github Actionsë¥¼ í†µí•´ í”„ë¡œì íŠ¸ì˜ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ê´€ë¦¬

#### ìë™í™”ë¥¼ ìœ„í•´ í™œìš©í•œ ë„êµ¬
- Github Actions
- Github Submodule
- Lokalise

#### ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ë‹¨ê³„
1. í´ë¼ìš°ë“œ ê¸°ë°˜ ë‹¤êµ­ì–´ ê´€ë¦¬ ì‹œìŠ¤í…œì¸ Lokaliseë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ì‘ì—…
2. Lokaliseë¥¼ í†µí•´ Github Submoduleì— PR ìƒì„±
3. PR ìƒì„±ì„ ê°ì§€í•´ Submoduleì˜ Workflow(localization.yml) ì‹¤í–‰ 
4. SwiftGenì„ í†µí•´ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ ì„ ì–¸ì ìœ¼ë¡œ ì‚¬ìš©ê°€ëŠ¥í•œ ì½”ë“œë¡œ ë³€í™˜ â†’ ì‘ì—… commit & merge â†’ ìŠ¬ë™ Webhookì„ í†µí•´ ì™„ë£Œ ë©”ì‹œì§€ ì „ë‹¬ â†’ í”„ë¡œì íŠ¸ ë©”ì¸ ë ˆí¬ì§€í† ë¦¬ì—ì„œ Submodule ìµœì‹ í™”ë¥¼ ìœ„í•´ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ íŠ¸ë¦¬ê±° ë°œë™
5. Submoduleì´ ì‹¤í–‰í•œ íŠ¸ë¦¬ê±° ê°ì§€í•´ì„œ í”„ë¡œì íŠ¸ ë©”ì¸ ë ˆí¬ì§€í† ë¦¬ì˜ Workflow(updateSubmodule.yml) ì‹¤í–‰ 
6. Submoduleì„ ìµœì‹ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸ í›„ ìŠ¬ë™ Webhookì„ í†µí•´ ì™„ë£Œ ë©”ì‹œì§€ ì „ë‹¬


<img width="800" alt="githubActions" src="https://github.com/user-attachments/assets/ccf64235-8b64-430c-8dfe-d6e148ca7744" />


> Submodule Reposiitoryì˜ Workflow (localization.yml)

```yaml


on:
  pull_request_target:
    types:
      - opened
      
permissions: write-all

jobs:

  localization:
    if: startsWith(github.head_ref, 'lokalise')
    runs-on: macos-latest
    steps:
      - name: Check out lokalise branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}
          
      - name: Print current branch
        run: git branch --show-current
      
      - name: Pull
        run: |
          git pull origin
      
      - name: Install Homebrew
        run: |
          echo "Checking Homebrew..."
          if ! command -v brew &> /dev/null; then
            echo "Installing Homebrew..."
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          else
            echo "Homebrew already installed."
          fi
          
      - name: Install SwiftGen
        run: |
          brew install swiftgen
            
      - name: Run SwiftGen
        run: |
          swiftgen config run --config swiftgen.yml
          
      - name: commit and push
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "[Success] complete localization build"


  review-and-merge:
    needs: localization
    if: ${{ needs.localization.result == 'success' }}
    
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}

      - name: Checkout base branch
        uses: actions/checkout@v3
        with:
          path: base_branch
          ref: ${{ github.base_ref }}

      - name: Get First Commit Message
        id: commit
        uses: actions/github-script@v6
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            const firstCommit = commits[0];
            core.setOutput('message', firstCommit.commit.message);
      
      - name: Merge PR
        id: merge
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }},
              merge_method: 'squash'
            });
        continue-on-error: true
        
      - name: Notify Slack on Merge Success
        if: steps.merge.outcome == 'success'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: webhook-trigger
          payload: |
            {
            "text": "ğŸ‰ PR Merge Success\n\nPR: ${{ github.event.pull_request.html_url }}\nBranch: `${{ github.head_ref }}`\nCommit: ${{ steps.commit.outputs.message }}"
            }
            
  dispatch-main-repo:
    needs: review-and-merge
    if: ${{ needs.review-and-merge.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Main Repository Workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.KOCO_GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: 'yyeonjju',
              repo: 'KoCo-Beauty',
              workflow_id: 'updateSubmodule.yml',
              ref: 'develop',
              inputs: {
                name: 'KoCo Main Repository'
              }
            });


```

> Project Repositoryì˜ Workflow (updateSubmodule.yml)


```yaml

on:
  workflow_dispatch:
    inputs:
      name:
        description: 'Input name'
        required: true
        type: string
  
permissions: write-all

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.KOCO_GITHUB_TOKEN }}
      
      - name: Pull & update submodules recursively
        run: |
          git submodule update --init --recursive
          git submodule update --recursive --remote
            
      - name: Commit & push
        id: commit
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "[Success] complete update submodule"

      - name: Notify Slack on Submodule Update Success
        if: steps.commit.outcome == 'success'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: webhook-trigger
          payload: |
            {
            "text": "ğŸ’ SubModule Update Success"
            }

```

