
# KoCo | í•œêµ­ ì½”ìŠ¤ë©”í‹± ì•±

![KoCo_En_1](https://github.com/user-attachments/assets/0a1f5473-9fd5-498f-9dc6-7cce7d4ebf9f) |![KoCo_En_2](https://github.com/user-attachments/assets/4ea1a0bd-d490-4dbb-8025-e5d9ea6e85f5) |![KoCo_En_3](https://github.com/user-attachments/assets/f04a665d-f289-4bb1-936a-2ca2926f355f) |![KoCo_En_4](https://github.com/user-attachments/assets/e5b688ae-4fb8-43fa-baaf-2258e7add4f8)
--- | --- | --- | --- |



<br/><br/>

## ğŸª— KoCo (Korea Cosmetic) 
- ì•± ì†Œê°œ : Kë·°í‹°ì— ê´€ì‹¬ìˆëŠ” ì™¸êµ­ì¸ ê´€ê´‘ê°ë“¤ì„ ìœ„í•œ ì½”ìŠ¤ë©”í‹± ë§¤ì¥/ìƒí’ˆ ê¸°ë¡ ì•±
- ê°œë°œ ì¸ì› : 1ì¸
- ê°œë°œ ê¸°ê°„ : ì•½ 3ì£¼
- ìµœì†Œ ë²„ì „ : 16.0


<br/><br/>

## ğŸ“ ê¸°ìˆ  ìŠ¤íƒ
- UI : SwiftUI
- Reactive : Combine
- Network : URLSession
- Architecture : MVVM
- Local DB : Realm
- ETC. : KakaoMapSDK, CoreLocation, GitHub Actions, Github Submodule, SwiftGen


<br/><br/>



## ğŸ“ í•µì‹¬ ê¸°ëŠ¥
- ìœ„ì¹˜ ê¸°ë°˜ ì£¼ë³€ ì½”ìŠ¤ë©”í‹± ë§¤ì¥ ê²€ìƒ‰
- ê¸°ê¸°ì— ì €ì¥ëœ ì–¸ì–´ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì–¸ì–´ í˜„ì§€í™”(í•œêµ­ì–´, ì˜ì–´, ì¤‘êµ­ì–´)
- íŠ¹ì • ë§¤ì¥ì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ì œê³µ
- ë§¤ì¥ì— ëŒ€í•œ ë¦¬ë·° ì‘ì„± ë° í”Œë˜ê·¸ ê¸°ëŠ¥


<br/><br/>


## âœ… í•µì‹¬ ê¸°ìˆ  êµ¬í˜„ ì‚¬í•­
- Github Submoduleê³¼ Lokaliseë¥¼ ê²°í•©í•´ ì‚¬ìš©í•˜ì—¬ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ Project Repositoryì™€ ë¶„ë¦¬í•˜ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬
- Github Actionsë¥¼ í™œìš©í•˜ì—¬ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ì—…ë°ì´íŠ¸ë¡œ ì¸í•œ Submodule Repositoryì˜ PR ìƒì„± ì‹œì ë¶€í„° Project Repositoryì— Submoduleì„ ìµœì‹ í™” í•˜ëŠ” ê³¼ì •ê¹Œì§€ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ê´€ë¦¬
- ETag(Entity tag) ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹± ë„ì…ìœ¼ë¡œ ì„œë²„ì™€ ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ ë²„ì „ ë™ê¸°í™” ë° ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„/ì„œë²„ ë¶€í•˜ ê°ì¶•
- ë°ì´í„° ì†ŒìŠ¤ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ì¤„ì´ê¸° ìœ„í•´ Repository Patternì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ì ‘ê·¼ ë¡œì§ì„ ì¶”ìƒí™”
- UIì— ê´€í•œ inputì„ viewModelì— ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬í•˜ê¸° ìœ„í•´ viewModel ë‚´ ì—´ê±°í˜•ìœ¼ë¡œ Action ì •ì˜
- ì´ë²¤íŠ¸ì— ë”°ë¼ ViewModelì˜ actionë©”ì„œë“œì— Actionì—´ê±°í˜•ì„ ì¸ìë¡œ ì „ë‹¬í•˜ì—¬ ë‹¨ë±¡í–¥ ë°ì´í„° ë°”ì¸ë”© ì§€í–¥ì ì¸ êµ¬ì¡° ì„¤ê³„
- ë§¤ì¥ ë¦¬ë·°ì— ì—…ë¡œë“œí•œ ì‚¬ì§„ì„ ì˜êµ¬ì ìœ¼ë¡œ ì €ì¥í•˜ê³  ì¡°íšŒí•˜ê¸° ìœ„í•´ FileManager ì‚¬ìš©í•˜ì—¬ ì €ì¥/ì¡°íšŒ ë¡œì§ êµ¬í˜„
- UIKit ê¸°ë°˜ ì½”ë“œë¥¼ SwiftUI í”„ë¡œì íŠ¸ì— ì‚¬ìš©í•˜ê¸° ìœ„í•´ UIViewRepresentable, Coordinatorì„ ê¸°ë°˜ìœ¼ë¡œ ë˜í•‘
- CoreLocationì„ ì‚¬ìš©í•´ ìœ„ì¹˜ ê¶Œí•œ ë° ì‚¬ìš©ìì˜ ìœ„ì¹˜ ì •ë³´ íšë“


<img width="800" alt="Architecture(KoCo)" src="https://github.com/user-attachments/assets/33b06824-205d-4752-8dc0-ea7275171e3e" />


<br/><br/>


## ğŸ’ ì£¼ìš” êµ¬í˜„ ë‚´ìš©
### 1. ETagÂ ê¸°ë°˜Â ImageÂ CacheÂ ì „ëµÂ ìˆ˜ë¦½ìœ¼ë¡œ ì´ë¯¸ì§€ ë¡œë”© ì„±ëŠ¥ 4ë°° í–¥ìƒ

#### ğŸ“ ETag(Entity tag)ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹œ ë„ì… ì´ìœ 
1. ë„¤íŠ¸ì›Œí¬ ë¶€í•˜ ê°ì†Œ : remoteDBì— ì €ì¥ëœ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë„¤íŠ¸ì›Œí‚¹ì— ëŒ€í•œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì„ ìµœì†Œí™”
2. ë¡œë“œ ì‹œê°„ ë‹¨ì¶• : ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„ ë‹¨ì¶•ìœ¼ë¡œ ì‚¬ìš©ì ê²½í—˜ ê°œì„ 
3. ì„œë²„ì™€ ë¦¬ì†ŒìŠ¤ ë™ê¸°í™” : ETag ê¸°ë°˜ì˜ ì´ë¯¸ì§€ ìºì‹± ìœ¼ë¡œ ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ ë³€ê²½ì— ëŒ€í•´ ì„œë²„ì™€ ë™ê¸°í™”

#### ğŸ“ ì´ë¯¸ì§€ ìºì‹± í”Œë¡œìš°
- ë©”ëª¨ë¦¬ ìºì‹œ Hit -> ë””ìŠ¤í¬ ìºì‹œ Hit
- -> ë©”ëª¨ë¦¬ í˜¹ì€ ë””ìŠ¤í¬ì— ì €ì¥í•´ ë†“ì€ ë°ì´í„°(etag, ì´ë¯¸ì§€ url ë“±)ê°€ ìˆë‹¤ë©´ í—¤ë”ì— 'If-None-Match'ë¥¼ í¬í•¨í•˜ì—¬ ì„œë²„ì— ìš”ì²­
- -> 304(Not Modified)ì—ëŸ¬ì˜ ê²½ìš° ê¸°ì¡´ì— ìºì‹±í•´ ë‘” ë°ì´í„° ë°˜í™˜ / ìƒíƒœì½”ë“œê°€ 200ì¼ ê²½ìš°ì—ëŠ” ìƒˆë¡œ ë°›ì€ ë°ì´í„° ë°˜í™˜

<img width="1127" alt="imageCache(etag)" src="https://github.com/user-attachments/assets/45f59867-69e2-4b00-845a-2b799591f64b" />


#### ğŸ“ ì´ë¯¸ì§€ ìºì‹œ ë§¤ë‹ˆì €
- CombineÂ Operatorë¥¼Â í™œìš©í•˜ì—¬Â StreamÂ ê´€ë¦¬
- ImageCachPolicy Enumì„ í†µí•´ ìºì‹± ì •ì±… ê´€ë¦¬ ë° ê° ìºì‹± ë¡œì§ì—ì„œ ImageCachPolicy ì—´ê±°í˜•ì„ ê¸°ì¤€ìœ¼ë¡œ ë¶„ê¸°ì²˜ë¦¬

```swift 

final class ImageCacheManager {
    // ...
    
    enum ImageCachPolicy {
        case both
        case memoryOnly
        case diskOnly
    }
    
    // ...

    func getImageData(urlString : String, policy : ImageCachPolicy = .both) -> AnyPublisher<Data?, ImageLoadError> {
        let subject = PassthroughSubject<CacheImage?, ImageLoadError>()
        
        switch policy {
        case .both:
            hitMemoryCache(urlString: urlString)
                .catch { [weak self] imageLoadError  in //ë©”ëª¨ë¦¬ì— ìºì‹±ë˜ì–´ ìˆì§€ ì•Šì„ ë•Œ
                    guard let self else{
                        return Just<CacheImage?>(nil)
                            .setFailureType(to: ImageLoadError.self)
                            .eraseToAnyPublisher()
                    }
                    //ë””ìŠ¤í¬ ìºì‹œ ì¡°íšŒ
                    return self.hitDiskCache(urlString: urlString)
                }
                .subscribe(subject)
                .store(in: &cancellables)
            
        case .memoryOnly:
            // ...
 
        case .diskOnly:
            // ...
        }

        return subject
            .catch { imageLoadError  in
                
                //ë©”ëª¨ë¦¬&ë””ìŠ¤í¬ì— ìºì‹±ë˜ì§€ ì•Šì•˜ë‹¤ëŠ” ì—ëŸ¬ë¥¼ ë°›ì€ ê²½ìš° -> ê¸°ë³¸ê°’ìœ¼ë¡œ ë‚´ë ¤ë³´ëƒ„
                return Just(CacheImage(imageData: Data(), etag: "-"))
                
            }
            .flatMap{[weak self] resultImage -> AnyPublisher<(Data,String?), ImageLoadError> in
                guard let self, let resultImage else {
                    return Fail(error: ImageLoadError.undefinedError).eraseToAnyPublisher()
                }
                let cachedEtag = resultImage.etag
                let cachedImageData = resultImage.imageData
                return self.synchronizeWithServer(urlString : urlString, etag: cachedEtag, cachedImageData : cachedImageData, policy: policy)
                    
            }
            .tryMap {[weak self] (imageData, etag) in
                guard let self else {return imageData}
                return imageData
            }
            .mapError{$0 as! ImageLoadError}
            .eraseToAnyPublisher()

    }
    
    // ...

}

```

#### ğŸ“ ì„œë²„ì™€ ë¦¬ì†ŒìŠ¤ ì¼ì¹˜ ì—¬ë¶€ í™•ì¸ ë° 304(Not Modified) ì—ëŸ¬ ë¶„ê¸°ì²˜ë¦¬
- If-None-Match í—¤ë”ë¥¼ í¬í•¨ì‹œí‚¨ HTTP ì¡°ê±´ë¶€ ìš”ì²­ìœ¼ë¡œ ë¡œì»¬ì— ìºì‹±ëœ ETag ê°’ê³¼ ì„œë²„ì˜ ë¦¬ì†ŒìŠ¤ë¥¼ ë¹„êµ ê²€ì¦
- HTTPURLResponseì˜ statusCodeê°€ 304 Not Modifiedì¼ ê²½ìš° ë¡œì»¬ ìºì‹œë¥¼ ì¬ì‚¬ìš©í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë„¤íŠ¸ì›Œí¬ íŠ¸ë˜í”½ì„ ìµœì†Œí™”


```swift 

    func synchronizeWithServer(urlString: String, etag : String, cachedImageData : Data, policy : ImageCachPolicy) -> AnyPublisher<(Data, String?), ImageLoadError> {

        guard let url = URL(string: urlString) else {
            return Fail<(Data, String?), ImageLoadError>(error: ImageLoadError.invalidUrlString).eraseToAnyPublisher()
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.addValue(etag, forHTTPHeaderField: "If-None-Match")

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { [weak self] result -> (Data, String?) in
                guard let self, let httpResponse = result.response as? HTTPURLResponse else {
                    throw ImageLoadError.noResponse
                }
                
                switch httpResponse.statusCode {
                case 200: // ì €ì¥ëœ etagë‘ ê°’ì´ ë‹¤ë¦„ -> ì‘ë‹µìœ¼ë¡œ ë°›ì€ ë°ì´í„° ë¦¬í„´
                    guard let newETag = httpResponse.allHeaderFields["Etag"] as? String else {
                        return (result.data, nil)
                    }
                    
                    //etag ê°€ ìˆì„ ê²½ìš° ìºì‹± ì •ì±…ëŒ€ë¡œ ìºì‹±
                    self.cacheImage(urlString: urlString, imageData: result.data, etag: newETag, policy: policy)
                    return (result.data, newETag)
                    
                case 304: // ì €ì¥ëœ etagë‘ ê°™ìŒ -> ì €ì¥ë˜ì–´ìˆë˜ ì´ë¯¸ì§€ ë°˜í™˜
                    return (cachedImageData, etag)
                default:
                    throw ImageLoadError.undefinedStatusCode
                }

            }
            .mapError { error -> ImageLoadError in
                if let error = error as? ImageLoadError {
                    return error
                } else {
                    return ImageLoadError.unknownError
                }
            }
            .eraseToAnyPublisher()

    }

```

#### ğŸ“ OSLogì™€ XCode Instrumentsë¥¼ ì‚¬ìš©í•œ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ ë¶„ì„
- ETag ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹± êµ¬í˜„ì˜ ì„±ëŠ¥ ê°œì„ ì„ ì •ëŸ‰ì ìœ¼ë¡œ ì¸¡ì •í•˜ê¸° ìœ„í•´ os_signpost APIë¥¼ í™œìš©í•œ ì •ë°€í•œ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ì„ ìˆ˜í–‰
- XCode Instrumentsì˜ System Traceë¥¼ í†µí•´ ìºì‹± ê¸°ëŠ¥ ì ìš© ì—¬ë¶€ ì‹œë‚˜ë¦¬ì˜¤ë³„ ì´ë¯¸ì§€ ë¡œë”© íƒ€ì„ë¼ì¸ì„ ì‹œê°í™”
- ê·¸ ê²°ê³¼ ETag ê¸°ë°˜ ì´ë¯¸ì§€ ìºì‹± ì ìš© í›„ì˜ í‰ê·  ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„ì´ ì•½ 75% ê°ì¶•(ì´ë¯¸ì§€ ë¡œë“œ ì„±ëŠ¥ ì•½ 4ë°° í–¥ìƒ)ë˜ëŠ” íš¨ê³¼ë¥¼ í™•ì¸

ğŸ“ğŸ“ ì´ë¯¸ì§€ ë¡œë“œ ì‹œê°„ 75% ë‹¨ì¶• ğŸ“ğŸ“

> â¬‡ï¸ Before : ìºì‹± ì ìš© ì „ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ (í‰ê·  800 ms)
<img width="450" alt="before_imageCache" src="https://github.com/user-attachments/assets/1975089d-ea8b-4f7a-b020-705111152646" />


> â¬‡ï¸ After : ìºì‹± ì ìš© í›„ ì´ë¯¸ì§€ ë¡œë“œ ì†ë„ (í‰ê·  200 ms)
<img width="450" alt="after_imageCache" src="https://github.com/user-attachments/assets/0d91ff16-3e88-46c9-b904-a65c43673a33" />


<br/><br/><br/>

### 2. Github Actionsë¥¼ í†µí•´ í”„ë¡œì íŠ¸ì˜ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ê´€ë¦¬


#### ğŸ“ ë‹¤êµ­ì–´ ê´€ë¦¬ ë°©ë²• ë³´ìˆ˜ ë° ê°œì„ 

ë³€ê²½ ë° ê°œì„  ì „
- String Catalogì™€ LocalizedStringKeyë¥¼ í™œìš©í•œ ë‹¤êµ­ì–´ ì²˜ë¦¬

<br/>

ë³€ê²½ ë° ê°œì„  í›„
- GitHub Submodule, Lokalise, GitHub Actions, SwiftGenë¥¼ í†µí•© í™œìš©í•˜ì—¬ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ êµ¬ì¶•
- ê° ë„êµ¬ì˜ ì„¸ë¶€ ì—­í• 
  - GitHub Submodule : GitHub Submoduleë¥¼ ë„ì…í•˜ì—¬ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ ëª¨ë“ˆí™”í•˜ê³  ë…ë¦½ì ì¸ ë²„ì „ ê´€ë¦¬
  - Lokalise : í´ë¼ìš°ë“œ ê¸°ë°˜ Localization í”Œë«í¼ Lokaliseë¥¼ ë„ì…í•˜ì—¬ ì•ˆì •ì ì´ê³  íš¨ìœ¨ì ì¸ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
  - GitHub Actions : Github Actionsë¥¼ ì‚¬ìš©í•´ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ì—…ë°ì´íŠ¸ ì‹œ, Submodule ë° í”„ë¡œì íŠ¸ ìµœì‹ í™”ê¹Œì§€ ì „ ê³¼ì •ì„ ìë™í™”
  - SwiftGen : SwiftGenì„ í†µí•´ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ Type-safe í•œ Swift ì½”ë“œë¡œ ìƒì„±í•˜ì—¬ ëŸ°íƒ€ì„Â ì—ëŸ¬Â ë°©ì§€Â ë°Â ì•ˆì •ì„±Â í™•ë³´ 

  
#### ğŸ“ ë‹¤êµ­ì–´ ê´€ë¦¬ ë°©ë²• ê°œì„  í›„ ì´ì 
- ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ì˜ ë…ë¦½ì  ê´€ë¦¬ë¡œ ë²„ì „ ê´€ë¦¬ê°€ ëª…í™•í•˜ê³  ë³€ê²½ ì´ë ¥ ì¶”ì ì´ ìš©ì´
- ì‹¤ì‹œê°„ í˜‘ì—…ê³¼ ì§„í–‰ ìƒí™© ì¶”ì ì´ ìš©ì´ 
- ìˆ˜ë™ ì‘ì—… ìµœì†Œí™”ë¡œ Human error ê°ì†Œ


#### ğŸ“ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ë‹¨ê³„
1. Lokalise í”Œë«í¼ì—ì„œ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ ìƒì„± ë° ê´€ë¦¬ ìˆ˜í–‰
2. Lokalise íŒŒì´í”„ë¼ì¸ì„ í†µí•œ GitHub Submodule Pull Request ìë™ ìƒì„±
3. PR ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°ë¡œ Submoduleì˜ Workflow(localization.yml) ì‹¤í–‰Â 
  - SwiftGenì„ í†µí•´ ë‹¤êµ­ì–´ ë¦¬ì†ŒìŠ¤ì˜ Type-safe ì½”ë“œ ìƒì„±
  - ë³€ê²½ì‚¬í•­ commit & merge í›„, Slack Webhookì„ í†µí•œ ì‘ì—… ì™„ë£Œ ì•Œë¦¼ ì „ì†¡
  - Submodule ë™ê¸°í™”ë¥¼ ìœ„í•œ ë©”ì¸ ë ˆí¬ì§€í† ë¦¬ Workflow íŠ¸ë¦¬ê±° ë°œìƒ
4. ë©”ì¸ ë ˆí¬ì§€í† ë¦¬ì—ì„œ íŠ¸ë¦¬ê±°ë¥¼ ê°ì§€ í›„, Workflow(updateSubmodule.yml) ì‹¤í–‰Â 
- Submodule ìµœì‹  ìƒíƒœ ë™ê¸°í™” ì™„ë£Œ í›„, Slack Webhookì„ í†µí•œ ì•Œë¦¼ ì „ì†¡

<img width="800" alt="githubActions" src="https://github.com/user-attachments/assets/f11f888b-f372-43ec-bf31-f25e9f6c5eb2" />


#### ğŸ“ Submodule Reposiitoryì˜ Workflow (localization.yml)

```yaml


on:
  pull_request_target:
    types:
      - opened
      
permissions: write-all

jobs:

  localization:
    if: startsWith(github.head_ref, 'lokalise')
    runs-on: macos-latest
    steps:
      - name: Check out lokalise branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}
          
      - name: Print current branch
        run: git branch --show-current
      
      - name: Pull
        run: |
          git pull origin
      
      - name: Install Homebrew
        run: |
          echo "Checking Homebrew..."
          if ! command -v brew &> /dev/null; then
            echo "Installing Homebrew..."
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          else
            echo "Homebrew already installed."
          fi
          
      - name: Install SwiftGen
        run: |
          brew install swiftgen
            
      - name: Run SwiftGen
        run: |
          swiftgen config run --config swiftgen.yml
          
      - name: commit and push
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "[Success] complete localization build"


  review-and-merge:
    needs: localization
    if: ${{ needs.localization.result == 'success' }}
    
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref }}

      - name: Checkout base branch
        uses: actions/checkout@v3
        with:
          path: base_branch
          ref: ${{ github.base_ref }}

      - name: Get First Commit Message
        id: commit
        uses: actions/github-script@v6
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            const firstCommit = commits[0];
            core.setOutput('message', firstCommit.commit.message);
      
      - name: Merge PR
        id: merge
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }},
              merge_method: 'squash'
            });
        continue-on-error: true
        
      - name: Notify Slack on Merge Success
        if: steps.merge.outcome == 'success'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: webhook-trigger
          payload: |
            {
            "text": "ğŸ‰ PR Merge Success\n\nPR: ${{ github.event.pull_request.html_url }}\nBranch: `${{ github.head_ref }}`\nCommit: ${{ steps.commit.outputs.message }}"
            }
            
  dispatch-main-repo:
    needs: review-and-merge
    if: ${{ needs.review-and-merge.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Main Repository Workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.KOCO_GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: 'yyeonjju',
              repo: 'KoCo-Beauty',
              workflow_id: 'updateSubmodule.yml',
              ref: 'develop',
              inputs: {
                name: 'KoCo Main Repository'
              }
            });


```

#### ğŸ“ Project Repositoryì˜ Workflow (updateSubmodule.yml)


```yaml

on:
  workflow_dispatch:
    inputs:
      name:
        description: 'Input name'
        required: true
        type: string
  
permissions: write-all

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          token: ${{ secrets.KOCO_GITHUB_TOKEN }}
      
      - name: Pull & update submodules recursively
        run: |
          git submodule update --init --recursive
          git submodule update --recursive --remote
            
      - name: Commit & push
        id: commit
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "[Success] complete update submodule"

      - name: Notify Slack on Submodule Update Success
        if: steps.commit.outcome == 'success'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: webhook-trigger
          payload: |
            {
            "text": "ğŸ’ SubModule Update Success"
            }

```

